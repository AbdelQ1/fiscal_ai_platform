# modules/ocr/configurable_invoice_ocr.py
"""
Module OCR configurable - Version finale, robuste et fonctionnelle.
Ce code est con√ßu pour sortir de la boucle de d√©bogage en fournissant
une base stable et une logique d'extraction intelligente.
"""

import re
from typing import Dict, List, Optional, Any
from pathlib import Path
import time
import logging
from dataclasses import dataclass

@dataclass
class InvoiceExtractionResult:
    """Structure de donn√©es pour un r√©sultat d'extraction propre et complet."""
    invoice_number: Optional[str] = None
    invoice_date: Optional[str] = None
    amounts_found: List[float] = None
    total_amount: Optional[float] = None
    subtotal_ht: Optional[float] = None
    vat_amount: Optional[float] = None
    legal_identifiers: Dict[str, str] = None
    extracted_entities: Dict[str, Any] = None
    extraction_confidence: float = 0.0
    processing_time: float = 0.0
    patterns_matched: List[str] = None
    success: bool = True
    error_message: str = ""

class ConfigurableInvoiceOCR:
    """OCR configurable fiable, optimis√© pour les factures fran√ßaises."""

    def __init__(self, config: Dict):
        self.config = config
        self.logger = self._setup_logging()
        
        # FIX : Assure que la configuration OCR est stable et correcte
        self.base_ocr_config = {
            "languages": config.get('languages', ['fra', 'eng']),
            "confidence_threshold": config.get('confidence_threshold', 0.65),
            "preprocessing": config.get('preprocessing', ["contrast", "denoise", "deskew"]),
            "fiscal_mode": False  # Force le mode qui a fonctionn√© dans le diagnostic
        }
        
        # FIX : Assure que tous les patterns sont charg√©s
        self.extraction_patterns = self._load_configurable_patterns()
        
        self.logger.info("üîß Module OCR Configurable Robuste Initialis√©.")
        self.logger.info(f"   - Patterns charg√©s: {len(self.extraction_patterns)} cat√©gories")
        self.logger.info(f"   - Configuration OCR: {self.base_ocr_config}")

    def _setup_logging(self):
        """Configure un logger simple pour un meilleur suivi."""
        logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
        return logging.getLogger(__name__)

    def _load_configurable_patterns(self) -> Dict[str, Dict]:
        """Charge un jeu de patterns complet et robuste."""
        # FIX : Jeu de patterns complet et √©prouv√©
        patterns = {
            'currency_amounts': {
                'patterns': [r'(\d{1,6}[,\.]\d{2})'],
                'flags': re.MULTILINE, 'description': 'Montants'
            },
            'french_dates': {
                'patterns': [
                    r'(\d{1,2}\s+(?:janvier|f√©vrier|fevrier|mars|avril|mai|juin|juillet|aout|ao√ªt|septembre|octobre|novembre|d√©cembre)\s+\d{4})',
                    r'(\d{2}/\d{2}/\d{4})'
                ],
                'flags': re.IGNORECASE, 'description': 'Dates'
            },
            'invoice_numbers': {
                'patterns': [
                    r'(\d{3}-\d{7}-\d{7})', # Format Amazon commande
                    r'facture\s*n¬∞?[:\s]*([A-Z0-9\-]{6,})'
                ],
                'flags': re.IGNORECASE, 'description': 'Num√©ros de facture'
            },
            'vat_numbers': {
                'patterns': [r'(FR\d{11})'],
                'flags': re.IGNORECASE, 'description': 'Num√©ros de TVA'
            }
        }
        return patterns

    def process_invoice(self, file_path: Path) -> InvoiceExtractionResult:
        """Point d'entr√©e principal pour traiter une facture."""
        start_time = time.time()
        try:
            self.logger.info(f"--- D√©but du traitement pour : {file_path.name} ---")
            raw_text = self._extract_text_with_base_ocr(file_path)
            if not raw_text or len(raw_text) < 200: # Seuil de qualit√©
                raise ValueError(f"Extraction OCR a produit un texte trop court ({len(raw_text)} caract√®res), traitement annul√©.")

            result = self._extract_structured_data(raw_text)
            result.processing_time = time.time() - start_time
            result.success = True
            self.logger.info(f"--- Extraction termin√©e avec une confiance de {result.extraction_confidence:.2f} ---")
            return result
        except Exception as e:
            self.logger.error(f"Erreur critique lors du traitement : {e}", exc_info=True)
            return InvoiceExtractionResult(success=False, error_message=str(e), processing_time=time.time() - start_time)

    def _extract_text_with_base_ocr(self, file_path: Path) -> str:
        """Utilise votre module OCR de base (qui fonctionne bien)."""
        try:
            from .base_ocr import FiscalOCRModule
            ocr = FiscalOCRModule(self.base_ocr_config)
            result = ocr.process_document(file_path, "invoice")
            self.logger.info(f"Texte extrait ({len(result.text)} caract√®res) avec une confiance de {result.confidence:.2f}")
            return result.text if result.success else ""
        except ImportError:
            self.logger.error("Le module 'base_ocr' est introuvable.")
            return ""
        except Exception as e:
            self.logger.error(f"Erreur dans le module OCR de base: {e}")
            return ""

    def _parse_float(self, value_str: str) -> Optional[float]:
        """Nettoie et convertit une cha√Æne en float de mani√®re robuste."""
        try:
            # G√®re les formats comme "1 234,56" ou "1,234.56"
            cleaned_str = value_str.replace(' ', '').replace(',', '.')
            if cleaned_str.count('.') > 1:
                 cleaned_str = cleaned_str.replace('.', '', cleaned_str.count('.') - 1)
            return float(cleaned_str)
        except (ValueError, TypeError):
            return None

    def _extract_and_select_amounts(self, amounts_raw: List[str]):
        """Logique robuste pour identifier Total, HT et TVA."""
        all_amounts = sorted(list(set(self._parse_float(v) for v in amounts_raw if self._parse_float(v))), reverse=True)
        
        total, ht, tva = None, None, None
        
        if not all_amounts:
            return [], None, None, None

        # Heuristique: le total est le plus grand montant.
        total = all_amounts[0]
        self.logger.info(f"Montants d√©tect√©s et tri√©s: {all_amounts}")
        self.logger.info(f"Montant total candidat (le plus √©lev√©): {total}")
        
        # Heuristique de validation : si on a 3 montants, on v√©rifie si Total ‚âà HT + TVA
        if len(all_amounts) >= 3:
            t_candidate, ht_candidate, tva_candidate = all_amounts[:3]
            if abs(t_candidate - (ht_candidate + tva_candidate)) < 0.1:
                total, ht, tva = t_candidate, ht_candidate, tva_candidate
                self.logger.info(f"Trio TTC/HT/TVA coh√©rent trouv√©: Total={total}, HT={ht}, TVA={tva}")

        return all_amounts, total, ht, tva

    def _extract_structured_data(self, text: str) -> InvoiceExtractionResult:
        """Applique les regex et la logique de s√©lection intelligente."""
        result = InvoiceExtractionResult(patterns_matched=[])
        extracted_data = {}

        for name, config in self.extraction_patterns.items():
            matches = []
            for pattern_str in config['patterns']:
                try:
                    pattern = re.compile(pattern_str, config.get('flags', re.IGNORECASE))
                    found = pattern.findall(text)
                    for match in found:
                        match_text = match[0] if isinstance(match, tuple) and match else match
                        if isinstance(match_text, str) and match_text.strip():
                            matches.append(match_text.strip())
                except re.error as e:
                    self.logger.warning(f"Pattern invalide pour {name}: {e}")
            
            if matches:
                extracted_data[name] = list(set(matches))
                result.patterns_matched.append(name)
        
        return self._map_extracted_data_to_result(result, extracted_data)

    def _map_extracted_data_to_result(self, result: InvoiceExtractionResult, extracted_data: Dict) -> InvoiceExtractionResult:
        """Mappe les donn√©es extraites vers la structure de r√©sultat finale."""
        self.logger.info(f"Donn√©es brutes extraites par regex: {extracted_data}")

        # --- Montants et Totaux ---
        raw_amounts = extracted_data.get('currency_amounts', [])
        amounts, total, ht, tva = self._extract_and_select_amounts(raw_amounts)
        result.amounts_found, result.total_amount, result.subtotal_ht, result.vat_amount = amounts, total, ht, tva

        # --- Num√©ro de TVA ---
        vat_number = extracted_data.get('vat_numbers', [None])[0]
        result.legal_identifiers = {'vat_number': vat_number} if vat_number else {}
        
        # --- Num√©ro de Facture ---
        invoice_number = None
        if 'invoice_numbers' in extracted_data:
            # Filtre pour exclure le num√©ro de TVA et prend le candidat le plus long/pertinent
            candidates = [c for c in extracted_data['invoice_numbers'] if c != vat_number]
            if candidates:
                invoice_number = max(candidates, key=len)
        result.invoice_number = invoice_number
        
        # --- Date de Facture ---
        result.invoice_date = extracted_data.get('french_dates', [None])[0]
        
        # --- Confiance et Entit√©s Finales ---
        confidence = 0.0
        if result.total_amount and result.total_amount > 1: confidence += 0.4
        if result.invoice_date: confidence += 0.2
        if result.invoice_number: confidence += 0.2
        if result.legal_identifiers.get('vat_number'): confidence += 0.2
        result.extraction_confidence = min(confidence, 1.0)
        
        result.extracted_entities = {
            'total_amount': result.total_amount,
            'subtotal_ht': result.subtotal_ht,
            'vat_amount': result.vat_amount,
            'invoice_date': result.invoice_date,
            'invoice_number': result.invoice_number,
            'vat_number': result.legal_identifiers.get('vat_number')
        }
        self.logger.info(f"R√©sultat final de l'extraction: {result.extracted_entities}")
        return result

    def get_configuration_info(self) -> Dict:
        """Retourne des informations sur la configuration actuelle."""
        return {
            'patterns_loaded': len(self.extraction_patterns),
            'pattern_categories': list(self.extraction_patterns.keys()),
            'languages': self.base_ocr_config.get('languages'),
            'data_protection': 'No hardcoded personal data values'
        }
